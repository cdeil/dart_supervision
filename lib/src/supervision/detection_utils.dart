import 'dart:convert';
import 'dart:io';
import '../numpy/ndarray.dart';
import 'detections.dart';

/// Utilities for loading and saving detections data.
class DetectionUtils {
  /// Loads detections from a JSON file generated by the Python script.
  ///
  /// [filePath] - Path to the JSON file containing detection data
  /// [frameIndex] - Index of the frame to load (0-based)
  ///
  /// Returns a Detections object with pixel coordinates (following Python supervision convention).
  static Future<Detections> loadFromJson(
      String filePath, int frameIndex) async {
    final file = File(filePath);
    if (!await file.exists()) {
      throw FileSystemException('Detection file not found', filePath);
    }

    final jsonString = await file.readAsString();
    final jsonData = json.decode(jsonString) as Map<String, dynamic>;

    final frames = jsonData['frames'] as List<dynamic>;
    if (frameIndex < 0 || frameIndex >= frames.length) {
      throw RangeError(
          'Frame index $frameIndex out of range [0, ${frames.length - 1}]');
    }

    final frameData = frames[frameIndex] as Map<String, dynamic>;
    final detectionsData = frameData['detections'] as Map<String, dynamic>;
    final videoInfo = jsonData['video_info'] as Map<String, dynamic>;

    // Parse normalized detections and convert to pixel coordinates
    final normalizedDetections = _parseDetectionsFromJson(detectionsData);
    return denormalizeCoordinates(
      normalizedDetections,
      videoInfo['width'] as int,
      videoInfo['height'] as int,
    );
  }

  /// Loads all frames from a JSON file.
  ///
  /// [filePath] - Path to the JSON file containing detection data
  ///
  /// Returns a list of Detections objects with pixel coordinates.
  static Future<List<Detections>> loadAllFramesFromJson(String filePath) async {
    final file = File(filePath);
    if (!await file.exists()) {
      throw FileSystemException('Detection file not found', filePath);
    }

    final jsonString = await file.readAsString();
    final jsonData = json.decode(jsonString) as Map<String, dynamic>;

    final frames = jsonData['frames'] as List<dynamic>;
    final videoInfo = jsonData['video_info'] as Map<String, dynamic>;
    final imageWidth = videoInfo['width'] as int;
    final imageHeight = videoInfo['height'] as int;

    final allDetections = <Detections>[];

    for (final frameData in frames) {
      final detectionsData = frameData['detections'] as Map<String, dynamic>;
      final normalizedDetections = _parseDetectionsFromJson(detectionsData);
      final pixelDetections = denormalizeCoordinates(
        normalizedDetections,
        imageWidth,
        imageHeight,
      );
      allDetections.add(pixelDetections);
    }

    return allDetections;
  }

  /// Gets video information from a JSON file.
  ///
  /// [filePath] - Path to the JSON file containing detection data
  ///
  /// Returns a map with video metadata.
  static Future<Map<String, dynamic>> getVideoInfo(String filePath) async {
    final file = File(filePath);
    if (!await file.exists()) {
      throw FileSystemException('Detection file not found', filePath);
    }

    final jsonString = await file.readAsString();
    final jsonData = json.decode(jsonString) as Map<String, dynamic>;

    return {
      'video_info': jsonData['video_info'],
      'model_info': jsonData['model_info'],
      'total_frames': (jsonData['frames'] as List).length,
    };
  }

  /// Parses detections from JSON data.
  static Detections _parseDetectionsFromJson(
      Map<String, dynamic> detectionsData) {
    final xyxyList = detectionsData['xyxy'] as List<dynamic>;
    final confidenceList = detectionsData['confidence'] as List<dynamic>;
    final classIdList = detectionsData['class_id'] as List<dynamic>;
    final trackerIdList = detectionsData['tracker_id'] as List<dynamic>;

    if (xyxyList.isEmpty) {
      return Detections.empty();
    }

    final numDetections = xyxyList.length;

    // Create xyxy array
    final xyxy = NDArray([numDetections, 4]);
    for (int i = 0; i < numDetections; i++) {
      final bbox = xyxyList[i] as List<dynamic>;
      for (int j = 0; j < 4; j++) {
        xyxy[[i, j]] = (bbox[j] as num).toDouble();
      }
    }

    // Create confidence array
    NDArray? confidence;
    if (confidenceList.isNotEmpty) {
      confidence = NDArray([numDetections]);
      for (int i = 0; i < numDetections; i++) {
        confidence[[i]] = (confidenceList[i] as num).toDouble();
      }
    }

    // Create class ID array
    NDArray? classId;
    if (classIdList.isNotEmpty) {
      classId = NDArray([numDetections]);
      for (int i = 0; i < numDetections; i++) {
        classId[[i]] = (classIdList[i] as num).toDouble();
      }
    }

    // Create tracker ID array
    NDArray? trackerId;
    if (trackerIdList.isNotEmpty) {
      trackerId = NDArray([numDetections]);
      for (int i = 0; i < numDetections; i++) {
        trackerId[[i]] = (trackerIdList[i] as num).toDouble();
      }
    }

    return Detections(
      xyxy: xyxy,
      confidence: confidence,
      classId: classId,
      trackerId: trackerId,
    );
  }

  /// Converts pixel coordinates to normalized coordinates.
  ///
  /// [detections] - Detections with pixel coordinates
  /// [imageWidth] - Width of the image
  /// [imageHeight] - Height of the image
  ///
  /// Returns detections with normalized coordinates (0-1 range).
  static Detections normalizeCoordinates(
    Detections detections,
    int imageWidth,
    int imageHeight,
  ) {
    if (detections.isEmpty) return detections;

    final normalizedXyxy = NDArray([detections.length, 4]);

    for (int i = 0; i < detections.length; i++) {
      // Normalize x coordinates
      normalizedXyxy[[i, 0]] = detections.xyxy[[i, 0]] / imageWidth;
      normalizedXyxy[[i, 2]] = detections.xyxy[[i, 2]] / imageWidth;

      // Normalize y coordinates
      normalizedXyxy[[i, 1]] = detections.xyxy[[i, 1]] / imageHeight;
      normalizedXyxy[[i, 3]] = detections.xyxy[[i, 3]] / imageHeight;
    }

    return Detections(
      xyxy: normalizedXyxy,
      confidence: detections.confidence,
      classId: detections.classId,
      trackerId: detections.trackerId,
    );
  }

  /// Converts normalized coordinates to pixel coordinates.
  ///
  /// [detections] - Detections with normalized coordinates
  /// [imageWidth] - Width of the image
  /// [imageHeight] - Height of the image
  ///
  /// Returns detections with pixel coordinates.
  static Detections denormalizeCoordinates(
    Detections detections,
    int imageWidth,
    int imageHeight,
  ) {
    if (detections.isEmpty) return detections;

    final pixelXyxy = NDArray([detections.length, 4]);

    for (int i = 0; i < detections.length; i++) {
      // Convert x coordinates to pixels
      pixelXyxy[[i, 0]] = detections.xyxy[[i, 0]] * imageWidth;
      pixelXyxy[[i, 2]] = detections.xyxy[[i, 2]] * imageWidth;

      // Convert y coordinates to pixels
      pixelXyxy[[i, 1]] = detections.xyxy[[i, 1]] * imageHeight;
      pixelXyxy[[i, 3]] = detections.xyxy[[i, 3]] * imageHeight;
    }

    return Detections(
      xyxy: pixelXyxy,
      confidence: detections.confidence,
      classId: detections.classId,
      trackerId: detections.trackerId,
    );
  }
}
